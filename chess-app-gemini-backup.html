<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="color-scheme" content="light only">
    <title>Malcolm's Chess v4.3</title>
    <style>
        /* Global resets: no side gaps, no scrolling */
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }

        /* Top bars: always visible */
        .button-bar {
            position: sticky;
            top: 0;
            z-index: 10;
            background-color: #2a2a2a;
            padding: 4px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            border-bottom: 2px solid #4CAF50;
        }

        .button-bar h1 {
            color: #4CAF50;
            margin-right: 30px;
            font-size: 24px;
        }

        .button-bar button {
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .button-bar button:nth-of-type(1) { background-color: rgb(128,0,128); }
        .button-bar button:nth-of-type(2) { background-color: rgb(34,139,34); }
        .button-bar button:nth-of-type(3) { background-color: rgb(70,130,180); }
        .button-bar button:nth-of-type(4) { background-color: rgb(139,0,0); }
        .button-bar button:hover { opacity: 0.8; }

        .move-message-container {
            padding: 10px 20px;
            background-color: #1a1a1a;
            border-bottom: 2px solid #4CAF50;
            margin-bottom: 2px;
            /* Fixed height to prevent expansion */
            height: 40px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            overflow: hidden;
        }

        .message-content {
            color: #4CAF50;
            font-size: 16px;
            text-align: center;
            font-weight: bold;
            width: 100%;
            /* Prevent text wrapping and overflow */
            white-space: nowrap;
            overflow: hidden;
            line-height: 1.2;
        }

        /* LOCKED POSITION - Green outline top aligned with message area bottom - DO NOT CHANGE */
        .chess-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            margin: 0;
            padding: 0;
            /* LOCKED POSITIONING - DO NOT MODIFY UNLESS EXPLICITLY REQUESTED */
            /* LOCKED HORIZONTAL CENTERING - EQUAL SPACING ON BOTH SIDES - DO NOT CHANGE */
        }

        /* Dynamic UI height calculations */
        :root {
            --ui-height: 0px; /* Will be updated by JavaScript based on actual measurements */
        }

        /* DYNAMIC GREEN OUTLINE - VIEWPORT-RESPONSIVE SQUARE DIMENSIONS */
        .chessboard {
            border: 3px solid #000080;
            background: transparent;
            box-sizing: border-box;
            margin: 0;
            /* DYNAMIC VIEWPORT-BASED SIZE - BOTTOM NEVER EXTENDS BELOW VIEWPORT */
            width: min(100vw, calc(100vh - var(--ui-height)));
            height: min(100vw, calc(100vh - var(--ui-height)));
            display: grid;
            /* RELATIVE GRID - EACH SQUARE IS 1/8TH OF DYNAMIC CHESSBOARD */
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 0;
            /* LOCKED CENTERING - EQUAL SPACING ON LEFT AND RIGHT SIDES - DO NOT CHANGE */
        }

        /* All device optimizations use dynamic UI height */
        @media (min-width: 768px) and (min-height: 800px) {
            .chessboard {
                display: grid;
                margin: 0;
                /* DYNAMIC VIEWPORT-BASED SIZE - BOTTOM NEVER EXTENDS BELOW VIEWPORT */
                width: min(100vw, calc(100vh - var(--ui-height)));
                height: min(100vw, calc(100vh - var(--ui-height)));
                /* RELATIVE GRID - EACH SQUARE IS 1/8TH OF DYNAMIC CHESSBOARD */
                grid-template-columns: repeat(8, 1fr);
                grid-template-rows: repeat(8, 1fr);
            }
        }

        .row {
            display: contents;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            /* HIERARCHICAL SIZING - CHESS PIECE SIZE RELATIVE TO SQUARE SIZE */
            font-size: 30px;
            cursor: pointer;
            user-select: none;
            position: relative;
            box-sizing: border-box;
            /* SQUARE INHERITS SIZE FROM GRID - NO FIXED DIMENSIONS */
            aspect-ratio: 1;
            overflow: hidden;
            /* Hardware acceleration for smooth drag */
            will-change: transform;
            transform: translateZ(0);
        }

        .light {
            background: #000000;
        }
        .dark {
            background: #4169e1;
        }

        /* SVG pieces styling */
        .piece {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            /* Smooth drag transitions */
            transition: transform 0.1s ease-out, opacity 0.1s ease-out;
            will-change: transform, opacity;
            transform: translateZ(0);
        }

        .piece svg {
            width: 70%;
            height: 70%;
            pointer-events: none;
            /* Hardware acceleration for SVG */
            will-change: transform;
            transform: translateZ(0);
        }

        /* Dragging state optimizations */
        .piece.dragging {
            transition: none; /* Remove transitions during active drag */
            transform: translateZ(0) scale(1.05);
            opacity: 0.8;
            z-index: 1000;
        }

        .piece.touch-dragging {
            transition: none; /* Remove transitions during touch drag */
            transform: translateZ(0) scale(1.05);
            opacity: 0.8;
            z-index: 1000;
        }

        /* Loading screen CSS moved inline for faster initial display */

        /* Loading indicator (legacy) */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            display: none;
        }

        /* Move message display */
        .move-message {
            text-align: center;
            padding: 15px;
            font-size: 22px;
            font-weight: bold;
            color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.1);
            border: 2px solid #4CAF50;
            border-radius: 10px;
            margin: 20px auto;
            max-width: 400px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        /* Spinning animation for thinking indicator */
        .spinner {
            display: inline-block;
            font-size: 16px;
            animation: spin 1s linear infinite;
            color: #4CAF50;
            transform-origin: center;
            /* Ensure spinner doesn't affect layout */
            line-height: 1;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* CHECK notification styling */
        .check-notification {
            background-color: red !important;
            color: white !important;
            animation: blink 1s infinite;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        /* Special styling for checkmate messages */
        .checkmate-message {
            background-color: #ff4444 !important;
            color: white !important;
            animation: checkmateGlow 2s infinite;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 18px;
            text-align: center;
        }

        @keyframes checkmateGlow {
            0%, 100% { background-color: #ff4444; transform: scale(1); }
            50% { background-color: #ff0000; transform: scale(1.05); }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        /* AI Move Animation Styles */
        .ai-highlight {
            animation: aiPieceBlink 0.5s linear infinite;
            transform-origin: center;
        }

        @keyframes aiPieceBlink {
            0%, 50% {
                transform: scale(1.2);
                filter: brightness(1.5) saturate(1.5);
            }
            51%, 100% {
                transform: scale(1.0);
                filter: brightness(1.0) saturate(1.0);
            }
        }

        .ai-moving {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
            transition: left 1.5s ease-in-out, top 1.5s ease-in-out;
        }

        .ai-move-line {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, #ff4444, #cc0000);
            transform-origin: 0 center;
            z-index: 999;
            border-radius: 2px;
            border: 1px solid white;
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
        }

        .ai-move-circle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #ff4444;
            border: 2px solid #cc0000;
            border-radius: 50%;
            z-index: 1000;
            box-shadow: 0 0 0 1px white, 0 0 8px rgba(255, 68, 68, 0.6);
            transform: translate(-50%, -50%);
        }

        .ai-move-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #cc0000;
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
            z-index: 1000;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 1px 0 white) drop-shadow(0 -1px 0 white) drop-shadow(1px 0 0 white) drop-shadow(-1px 0 0 white) drop-shadow(0 0 6px rgba(255, 68, 68, 0.8));
        }

        /* Force consistent SVG rendering across browsers */
        svg {
            color-scheme: light only !important;
            forced-color-adjust: none !important;
        }

        svg path, svg g {
            color-scheme: light only !important;
            forced-color-adjust: none !important;
        }
    </style>
</head>
<body>
    <script>
        // CELLULAR OPTIMIZATION: Style the Chess text nicely and wait for full content
        document.body.style.margin = '0';
        document.body.style.padding = '0';
        document.body.style.background = '#1a1a1a';
        document.body.style.color = '#4CAF50';
        document.body.style.fontFamily = 'Arial, sans-serif';
        document.body.style.fontSize = '48px';
        document.body.style.fontWeight = 'bold';
        document.body.style.display = 'flex';
        document.body.style.justifyContent = 'center';
        document.body.style.alignItems = 'center';
        document.body.style.height = '100vh';

        console.log('CELLULAR: Styled Chess text, waiting for full HTML...');

        // Add loading indicator after Chess text
        setTimeout(function() {
            // Add a loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.style.position = 'absolute';
            loadingDiv.style.bottom = '40%';
            loadingDiv.style.width = '100%';
            loadingDiv.style.textAlign = 'center';
            loadingDiv.style.fontSize = '24px';
            loadingDiv.style.color = '#888';
            loadingDiv.innerHTML = 'Loading...';
            document.body.appendChild(loadingDiv);

            console.log('CELLULAR: Added loading indicator');
        }, 200);

        // Wait for the HTML structure to load, then clear Chess text and show proper content
        function waitForFullContent() {
            // Check if the main chess app elements are loaded
            if (document.getElementById('instant-loading') && document.getElementById('loading-screen')) {
                console.log('CELLULAR: Full HTML loaded, switching to proper loading screen...');

                // Clear the Chess text and loading indicator
                const walker = document.createTreeWalker(
                    document.body,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                const textNodes = [];
                let node;
                while (node = walker.nextNode()) {
                    if (node.nodeValue.trim() === 'Chess' || node.nodeValue.trim() === 'Loading...') {
                        textNodes.push(node);
                    }
                }
                textNodes.forEach(n => n.remove());

                // Remove any temporary divs we added
                const tempDivs = document.querySelectorAll('div');
                tempDivs.forEach(div => {
                    if (div.innerHTML === 'Loading...' && div.style.position === 'absolute') {
                        div.remove();
                    }
                });

                // Reset body styles for proper app display
                document.body.style.display = 'flex';
                document.body.style.flexDirection = 'column';
                document.body.style.fontSize = '';
                document.body.style.fontWeight = '';
                document.body.style.justifyContent = '';
                document.body.style.alignItems = '';

                console.log('CELLULAR: Transition complete!');
            } else {
                // Keep checking every 200ms
                setTimeout(waitForFullContent, 200);
            }
        }

        // Start checking after 1 second to give Chess text time to display
        setTimeout(waitForFullContent, 1000);
    </script>

    <!-- Instant loading feedback - displays immediately -->
    <div id="instant-loading" style="position:fixed;top:0;left:0;width:100%;height:100%;background:#1a1a1a;color:#4CAF50;font:bold 28px Arial;display:flex;justify-content:center;align-items:center;z-index:10000;">
        Malcolm's Chess v4.3
        <div style="position:absolute;top:60%;font:16px Arial;color:#ccc">Loading...</div>
    </div>

    <!-- Full loading screen - replaces instant loading -->
    <div id="loading-screen" style="position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(135deg,#1a1a1a 0%,#2a2a2a 100%);display:none;flex-direction:column;justify-content:center;align-items:center;z-index:9999;color:white;font-family:Arial,sans-serif;">
        <div style="text-align:center;max-width:400px;padding:40px;">
            <div style="font-size:28px;font-weight:bold;color:#4CAF50;margin-bottom:10px;">Malcolm's Chess v4.1</div>
            <div style="font-size:16px;color:#ccc;margin-bottom:30px;">Loading chess application...</div>
            <div id="loading-spinner" style="width:50px;height:50px;border:4px solid #333;border-top:4px solid #4CAF50;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 20px;"></div>
            <div id="loading-progress" style="font-size:14px;color:#888;margin-bottom:20px;">Initializing...</div>
            <div id="progress-container" style="display:none;">
                <div style="width:300px;height:6px;background-color:#333;border-radius:3px;overflow:hidden;margin:0 auto 15px;">
                    <div id="progress-bar" style="height:100%;background:linear-gradient(90deg,#4CAF50,#66BB6A);border-radius:3px;width:0%;transition:width 0.3s ease-out;"></div>
                </div>
                <div id="progress-percentage" style="font-size:12px;color:#4CAF50;font-weight:bold;">0%</div>
            </div>
        </div>
    </div>

    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>

    <script>
        // Progressive enhancement - switch to full loading screen after minimal delay
        setTimeout(function(){
            document.getElementById('instant-loading').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'flex';
        }, 100);
    </script>

    <div class="button-bar">
        <h1>Malcolm's Chess v4.3</h1>
        <button onclick="undoLastMove()">Undo</button>
        <button onclick="redoLastMove()">Redo</button>
        <button onclick="location.reload()">Refresh</button>
        <button onclick="startNew()">New</button>
    </div>

    <div class="move-message-container">
        <div class="message-content" id="moveMessage">Game ready</div>
    </div>

    <div class="chess-container">
        <div class="chessboard" id="chessboard">
            <!-- Static chess board structure -->
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            boardData: null,
            selectedSquare: null,
            draggedPiece: null,
            currentPlayer: 'White',
            preAiBoard: null,
            showGameReady: true,  // Flag to show Game Ready message initially
            aiMoveInProgress: false,
            lastAiMove: null,
            currentAiMoveLine: null,
            currentAiMoveCircle: null,
            currentAiMoveArrow: null
        };

        // Loading screen management with progress tracking
        let loadingProgress = {
            htmlLoaded: false,
            domReady: false,
            boardInitialized: false,
            piecesLoaded: false,
            gameReady: false
        };

        function updateProgress(stage, message) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('loading-progress');
            const progressPercentage = document.getElementById('progress-percentage');
            const progressContainer = document.getElementById('progress-container');

            // Mark stage as complete
            loadingProgress[stage] = true;

            // Calculate overall progress
            const stages = Object.keys(loadingProgress);
            const completedStages = stages.filter(s => loadingProgress[s]).length;
            const progressPercent = Math.round((completedStages / stages.length) * 100);

            // Show progress bar container once we have some progress
            if (progressContainer && progressPercent > 0) {
                progressContainer.style.display = 'block';
            }

            // Update UI
            if (progressBar) {
                progressBar.style.width = progressPercent + '%';
            }
            if (progressText) {
                progressText.textContent = message;
            }
            if (progressPercentage) {
                progressPercentage.textContent = progressPercent + '%';
            }

            console.log(`Loading Progress: ${stage} complete - ${progressPercent}% - ${message}`);

            // Hide loading screen when everything is ready
            if (progressPercent === 100) {
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loading-screen');
                    const instantLoading = document.getElementById('instant-loading');
                    if (loadingScreen) {
                        loadingScreen.style.opacity = '0';
                        loadingScreen.style.transition = 'opacity 0.5s ease-out';
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                        }, 500);
                    }
                    if (instantLoading) {
                        instantLoading.style.display = 'none';
                    }
                }, 300); // Brief pause to show 100%
            }
        }

        // Initialize progress tracking
        function initializeLoadingSystem() {
            // Stage 1: HTML loaded (this runs immediately since script is executing)
            updateProgress('htmlLoaded', 'HTML content loaded...');

            // Stage 2: DOM ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    updateProgress('domReady', 'DOM structure ready...');
                    initializeGameComponents();
                });
            } else {
                updateProgress('domReady', 'DOM structure ready...');
                initializeGameComponents();
            }
        }

        function initializeGameComponents() {
            // Stage 3: Board initialization
            setTimeout(() => {
                initializeDynamicSizing(); // Set up dynamic UI height calculations
                initializeBoard(); // Create static board structure
                updateProgress('boardInitialized', 'Initializing chess board...');

                // Stage 4: Load chess pieces
                setTimeout(() => {
                    updateBoard();     // Load initial piece positions
                    updateProgress('piecesLoaded', 'Loading chess pieces...');

                    // Stage 5: Game ready
                    setTimeout(() => {
                        updateStatus();    // Initialize status message
                        updateProgress('gameReady', 'Game ready!');
                    }, 200);
                }, 300);
            }, 200);
        }

        // Start loading system immediately
        initializeLoadingSystem();

        // Dynamic UI height calculation
        function updateUIHeight() {
            const buttonBar = document.querySelector('.button-bar');
            const messageContainer = document.querySelector('.move-message-container');
            const chessContainer = document.querySelector('.chess-container');

            if (buttonBar && messageContainer && chessContainer) {
                // Get the actual position where the chess container starts
                const chessContainerTop = chessContainer.offsetTop;

                // Calculate remaining viewport height from chess container position
                const availableHeight = window.innerHeight - chessContainerTop;

                // Reserve small buffer (10px) to ensure bottom border is visible
                const reservedHeight = chessContainerTop + 10;

                document.documentElement.style.setProperty('--ui-height', `${reservedHeight}px`);

            }
        }

        // Update UI height on load and resize
        function initializeDynamicSizing() {
            updateUIHeight();

            // Update on window resize
            window.addEventListener('resize', updateUIHeight);

            // Update when DOM changes (e.g., message content changes)
            const observer = new MutationObserver(updateUIHeight);
            const messageArea = document.getElementById('moveMessage');
            if (messageArea) {
                observer.observe(messageArea, { childList: true, subtree: true, characterData: true });
            }
        }

        // Initialize static board structure (called once)
        function initializeBoard() {
            let board = document.getElementById('chessboard');
            if (board) {
                let html = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        let isLight = (r + c) % 2 === 0;
                        html += `<div class="square ${isLight ? 'light' : 'dark'}" id="square-${r}-${c}"></div>`;
                    }
                }
                board.innerHTML = html;

                // Set up event delegation for drag and drop
                board.addEventListener('dragover', allowDrop);
                board.addEventListener('drop', function(event) {
                    event.preventDefault();
                    let square = event.target.closest('.square');
                    if (square && dragSource) {
                        let squareId = square.id;
                        let match = squareId.match(/square-(\d)-(\d)/);
                        if (match) {
                            let row = parseInt(match[1]);
                            let col = parseInt(match[2]);
                            attemptMove(dragSource.row, dragSource.col, row, col);
                        }
                    }
                    // Clean up will be handled by handleDragEnd
                });
            }
        }

        // Update only piece positions (preserves static board)
        function updateBoard() {
            fetch('/api/board')
                .then(r => r.json())
                .then(data => {
                    // Clear all squares first
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            let square = document.getElementById(`square-${r}-${c}`);
                            if (square) {
                                square.innerHTML = '';
                            }
                        }
                    }

                    // Place pieces in their current positions
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            let piece = data.board[r] ? data.board[r][c] || '' : '';
                            if (piece) {
                                let square = document.getElementById(`square-${r}-${c}`);
                                if (square) {
                                    const pieceSVG = getPieceSVG(piece);
                                    square.innerHTML = `<div class="piece" draggable="true" ondragstart="handleDragStart(event,${r},${c})" ondragend="handleDragEnd(event)" ontouchstart="handleTouchStart(event,${r},${c})" ontouchend="handleTouchEnd(event)">${pieceSVG}</div>`;
                                }
                            }
                        }
                    }
                })
                .catch(e => {
                });
        }

        // Generate SVG for chess pieces
        function getPieceSVG(pieceCode) {
            if (!pieceCode) return '';

            const pieceType = pieceCode.substring(1);
            const isWhite = pieceCode[0] === 'w';
            // Use contrasting stroke colors that work across all browsers/modes
            const fill = isWhite ? '#ffffff' : '#000000';
            const stroke = isWhite ? '#000000' : '#ffffff';

            const basePieces = {
                'p': `<path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`,
                'r': `<g fill="${fill}" stroke="${stroke}" stroke-width="1.5"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" fill="none"/></g>`,
                'n': `<g fill="${fill}" stroke="${stroke}" stroke-width="1.5"><path d="M22,10 C32.5,11 38.5,18 38,39 L15,39 C15,30 25,32.5 23,18"/><path d="M24,18 C24.38,20.91 18.45,25.37 16,27 C13,29 13.18,31.34 11,31 C9.958,30.06 12.41,27.96 11,28 C10,28 11.19,29.23 10,30 C9,30 5.997,31 6,26 C6,24 12,14 12,14 C12,14 13.89,12.1 14,10.5 C13.27,9.506 13.5,8.5 13.5,7.5 C14.5,6.5 16.5,10 16.5,10 L18.5,10 C18.5,10 19.28,8.008 21,7 C22,7 22,10 22,10"/></g>`,
                'b': `<g fill="${fill}" stroke="${stroke}" stroke-width="1.5"><path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2zM15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2zM25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g>`,
                'q': `<g fill="${fill}" stroke="${stroke}" stroke-width="1.5"><circle cx="6" cy="12" r="2.5"/><circle cx="14" cy="9" r="2.5"/><circle cx="22.5" cy="7.5" r="2.5"/><circle cx="31" cy="9" r="2.5"/><circle cx="39" cy="12" r="2.5"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-14V25L7 14l2 12zM9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/></g>`,
                'k': `<g fill="${fill}" stroke="${stroke}" stroke-width="1.5"><path d="M22.5 11.63V6M20 8h5" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z"/></g>`
            };

            if (!basePieces[pieceType]) return '';
            return `<svg viewBox="0 0 45 45" width="100%" height="100%">${basePieces[pieceType]}</svg>`;
        }

        // Button functions
        function startNew() {
            gameState.showGameReady = true; // Set flag to show Game Ready message

            // Clear any existing AI move indicators (red circle, line, arrow)
            if (gameState.currentAiMoveLine) {
                gameState.currentAiMoveLine.remove();
                gameState.currentAiMoveLine = null;
            }
            if (gameState.currentAiMoveCircle) {
                gameState.currentAiMoveCircle.remove();
                gameState.currentAiMoveCircle = null;
            }
            if (gameState.currentAiMoveArrow) {
                gameState.currentAiMoveArrow.remove();
                gameState.currentAiMoveArrow = null;
            }

            fetch('/api/newgame', {method: 'POST'})
                .then(() => {
                    fetch('/api/reset', {method: 'POST'})
                        .then(() => {
                            updateBoard();
                            // Show Game Ready immediately
                            let m = document.getElementById('moveMessage');
                            if (m) {
                                m.innerHTML = 'Game ready';
                            }
                            setTimeout(() => {
                                updateStatus(); // Update status after game reset
                            }, 500);
                        });
                });
        }

        function undoLastMove() {
            fetch('/api/undo', {method: 'POST'})
                .then(r => r.json())
                .then(result => {
                    if (result.success) {
                        updateBoard();
                        setTimeout(updateStatus, 300);
                    }
                });
        }

        function redoLastMove() {
            fetch('/api/redo', {method: 'POST'})
                .then(r => r.json())
                .then(result => {
                    if (result.success) {
                        updateBoard();
                        setTimeout(updateStatus, 300);
                    }
                });
        }

        function showGameReadyMessage() {
            let m = document.getElementById('moveMessage');
            if (m) {
                m.innerHTML = 'Game ready';
                // After a short delay, check the actual game status
                setTimeout(updateStatus, 1000);
            }
        }

        // Track game state to detect checkmate
        let lastMoveCount = -1;
        let stuckTurnCounter = 0;

        function updateStatus() {
            fetch('/api/status')
                .then(r => r.json())
                .then(s => {
                    let m = document.getElementById('moveMessage');
                    if (m) {
                        // Detect if game is stuck (same moveCount and player in check for multiple updates)
                        if (s.moveCount === lastMoveCount && (s.whiteInCheck || s.blackInCheck)) {
                            stuckTurnCounter++;

                            // If stuck for 5+ status updates, likely checkmate
                            if (stuckTurnCounter >= 5) {
                                let winner = s.currentPlayer.toLowerCase() === 'white' ? 'Black' : 'White';
                                m.innerHTML = '<div class="checkmate-message">🏆 CHECKMATE! 🏆<br>' + winner + ' Wins the Game!</div>';
                                return; // Exit early to stop further processing
                            }
                        } else {
                            stuckTurnCounter = 0; // Reset counter if game progresses
                            lastMoveCount = s.moveCount;
                        }

                        // Check for explicit game end conditions
                        if (!s.gameActive || s.status === 'checkmate' || s.status === 'stalemate') {
                            if (s.status === 'checkmate') {
                                let winner = s.currentPlayer.toLowerCase() === 'white' ? 'Black' : 'White';
                                m.innerHTML = '<div class="checkmate-message">🏆 CHECKMATE! 🏆<br>' + winner + ' Wins the Game!</div>';
                            } else if (s.status === 'stalemate') {
                                m.innerHTML = '<div class="checkmate-message">⚖️ STALEMATE ⚖️<br>The game is a draw.</div>';
                            } else if (!s.gameActive) {
                                m.innerHTML = 'Game Over';
                            }
                        } else if (s.currentPlayer.toLowerCase() === 'white') {
                            // Check if we should show Game Ready instead of turn message
                            if (gameState.showGameReady) {
                                m.innerHTML = 'Game ready';
                            } else if (gameState.aiMoveInProgress) {
                                // Don't show white's turn message while AI animation is still playing
                                m.innerHTML = 'Black is thinking... <span class="spinner">◐</span>';
                            } else {
                                let message = 'White, it is your turn to move';
                                if (s.whiteInCheck) {
                                    message = '<span class="check-notification">White King is in Check.</span> ' + message;
                                }
                                m.innerHTML = message;
                            }
                        } else if (s.currentPlayer.toLowerCase() === 'black') {
                            let message = 'Black is thinking';
                            if (s.blackInCheck) {
                                message = '<span class="check-notification">Black King is in Check.</span> Black is thinking';
                            }
                            m.innerHTML = message + '... <span class="spinner">◐</span>';
                        } else {
                            // Fallback if currentPlayer is not recognized
                            m.innerHTML = 'Game ready';
                        }
                    }
                })
                .catch(e => {
                });
        }

        // Drag and drop handling (desktop) + Touch handling (iPad/mobile)
        let dragSource = null;
        let touchStartSource = null;
        let isDragging = false;
        let backgroundUpdatesEnabled = true;

        function handleDragStart(event, row, col) {
            dragSource = {row: row, col: col};
            event.dataTransfer.effectAllowed = 'move';

            // Set drag state and optimize performance
            isDragging = true;
            backgroundUpdatesEnabled = false; // Pause background updates

            // Add dragging class for visual feedback
            const square = document.getElementById(`square-${row}-${col}`);
            if (square && square.firstChild) {
                square.firstChild.classList.add('dragging');
                // Use requestAnimationFrame for smooth updates
                requestAnimationFrame(() => {
                    square.firstChild.style.willChange = 'transform, opacity';
                });
            }
        }

        function allowDrop(event) {
            event.preventDefault();
        }

        function handleDragEnd(event) {
            // Clean up drag state
            isDragging = false;
            backgroundUpdatesEnabled = true; // Resume background updates

            // Remove dragging class and reset styles
            const allPieces = document.querySelectorAll('.piece');
            allPieces.forEach(piece => {
                piece.classList.remove('dragging');
                requestAnimationFrame(() => {
                    piece.style.willChange = 'auto';
                });
            });

            dragSource = null;
        }

        // Touch event handlers for iPad/mobile compatibility
        function handleTouchStart(event, row, col) {
            event.preventDefault();
            touchStartSource = {row: row, col: col};

            // Set touch drag state and optimize performance
            isDragging = true;
            backgroundUpdatesEnabled = false; // Pause background updates

            // Add visual feedback for touch with smooth transitions
            const square = document.getElementById(`square-${row}-${col}`);
            if (square && square.firstChild) {
                const piece = square.firstChild;
                piece.classList.add('touch-dragging');

                requestAnimationFrame(() => {
                    piece.style.willChange = 'transform, opacity';
                    // Use hardware-accelerated transform instead of opacity
                    piece.style.transform = 'translateZ(0) scale(1.05)';
                    piece.style.opacity = '0.8';
                });
            }
        }

        function handleTouchEnd(event) {
            event.preventDefault();

            // Clean up touch drag state
            isDragging = false;
            backgroundUpdatesEnabled = true; // Resume background updates

            // Remove visual feedback with smooth transitions
            if (touchStartSource) {
                const sourceSquare = document.getElementById(`square-${touchStartSource.row}-${touchStartSource.col}`);
                if (sourceSquare && sourceSquare.firstChild) {
                    const piece = sourceSquare.firstChild;
                    piece.classList.remove('touch-dragging');

                    requestAnimationFrame(() => {
                        piece.style.transform = 'translateZ(0) scale(1)';
                        piece.style.opacity = '1';
                        // Reset will-change after transition
                        setTimeout(() => {
                            piece.style.willChange = 'auto';
                        }, 150);
                    });
                }
            }

            // Find the square under the touch point
            const touch = event.changedTouches[0];
            const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetSquare = elementUnderTouch ? elementUnderTouch.closest('.square') : null;

            if (targetSquare && touchStartSource) {
                const squareId = targetSquare.id;
                const match = squareId.match(/square-(\d)-(\d)/);
                if (match) {
                    const row = parseInt(match[1]);
                    const col = parseInt(match[2]);
                    attemptMove(touchStartSource.row, touchStartSource.col, row, col);
                }
            }

            touchStartSource = null;
        }

        // AI Move Animation Functions
        function blinkAiPiece(row, col, callback) {
            const square = document.getElementById(`square-${row}-${col}`);
            const piece = square ? square.firstChild : null;


            if (piece) {
                piece.classList.add('ai-highlight');
                // Force a style recalculation to ensure the animation starts
                piece.offsetHeight;

                setTimeout(() => {
                    piece.classList.remove('ai-highlight');
                    if (callback) callback();
                }, 1000); // Reduced to 1 second to prevent board update conflicts
            } else {
                if (callback) callback();
            }
        }

        function animateAiPieceMove(fromRow, fromCol, toRow, toCol, callback) {
            console.log(`=== ANIMATION DEBUG ===`);
            console.log(`Animating from (${fromRow},${fromCol}) to (${toRow},${toCol})`);

            const fromSquare = document.getElementById(`square-${fromRow}-${fromCol}`);
            const toSquare = document.getElementById(`square-${toRow}-${toCol}`);

            console.log(`From square element:`, fromSquare);
            console.log(`To square element:`, toSquare);

            // If piece is missing from source, try to find it at destination (board already updated)
            let piece = fromSquare ? fromSquare.firstChild : null;
            if (!piece && toSquare) {
                piece = toSquare.firstChild;
                if (piece) {
                    // Create a simple red line and skip piece movement since it's already moved
                    if (fromSquare && toSquare) {
                        const chessboard = document.getElementById('chessboard');

                        // Calculate square dimensions using grid math
                        const boardRect = chessboard.getBoundingClientRect();
                        const boardWidth = boardRect.width - 6; // subtract 3px border on each side
                        const boardHeight = boardRect.height - 6;
                        const squareWidth = boardWidth / 8;
                        const squareHeight = boardHeight / 8;

                        // Calculate center positions using grid coordinates
                        const fromX = (fromCol * squareWidth) + (squareWidth / 2);
                        const fromY = (fromRow * squareHeight) + (squareHeight / 2);
                        const toX = (toCol * squareWidth) + (squareWidth / 2);
                        const toY = (toRow * squareHeight) + (squareHeight / 2);

                        console.log(`From position: (${fromX}, ${fromY})`);
                        console.log(`To position: (${toX}, ${toY})`);

                        // Debug the line positioning
                        console.log(`Line will be positioned at: left=${fromX}px, top=${fromY-2}px`);
                        console.log(`Line delta: dx=${toX - fromX}, dy=${toY - fromY}`);

                        // Create red trail line
                        const line = document.createElement('div');
                        line.className = 'ai-move-line';

                        const deltaX = toX - fromX;
                        const deltaY = toY - fromY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;

                        // Line starts from exact center of circle
                        line.style.width = distance + 'px';
                        line.style.left = fromX + 'px';
                        line.style.top = (fromY - 2) + 'px';
                        line.style.transform = `rotate(${angle}deg)`;
                        line.style.transformOrigin = '0 center';

                        chessboard.appendChild(line);
                        gameState.currentAiMoveLine = line;

                        // Create red circle at source position (centered)
                        const circle = document.createElement('div');
                        circle.className = 'ai-move-circle';
                        circle.style.left = fromX + 'px';
                        circle.style.top = fromY + 'px';
                        chessboard.appendChild(circle);
                        gameState.currentAiMoveCircle = circle;

                        // Create arrow at destination position
                        const arrow = document.createElement('div');
                        arrow.className = 'ai-move-arrow';
                        arrow.style.left = toX + 'px';
                        arrow.style.top = toY + 'px';
                        arrow.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
                        chessboard.appendChild(arrow);
                        gameState.currentAiMoveArrow = arrow;

                        // Keep line, circle, and arrow visible permanently
                        setTimeout(() => {
                            // Keep visual indicators visible: line, circle, and arrow remain on screen
                            if (callback) callback();
                        }, 1500);
                        return;
                    }
                }
            }


            if (!piece || !fromSquare || !toSquare) {
                if (callback) callback();
                return;
            }


            // Get positions
            const chessboard = document.getElementById('chessboard');
            const fromRect = fromSquare.getBoundingClientRect();
            const toRect = toSquare.getBoundingClientRect();
            const boardRect = chessboard.getBoundingClientRect();

            // Create animated piece
            const animatedPiece = piece.cloneNode(true);
            animatedPiece.classList.add('ai-moving');

            // Position the animated piece
            animatedPiece.style.left = (fromRect.left - boardRect.left) + 'px';
            animatedPiece.style.top = (fromRect.top - boardRect.top) + 'px';
            animatedPiece.style.width = fromRect.width + 'px';
            animatedPiece.style.height = fromRect.height + 'px';

            chessboard.style.position = 'relative';
            chessboard.appendChild(animatedPiece);

            // Hide original piece
            piece.style.opacity = '0';

            // Step 1: Animate piece movement FIRST
            setTimeout(() => {
                animatedPiece.style.left = (toRect.left - boardRect.left) + 'px';
                animatedPiece.style.top = (toRect.top - boardRect.top) + 'px';

                // Step 2: After piece reaches destination, draw red line
                setTimeout(() => {
                    // Create red trail line AFTER piece has moved
                    const line = document.createElement('div');
                    line.className = 'ai-move-line';

                    // Calculate square dimensions using grid math
                    const boardRect = chessboard.getBoundingClientRect();
                    const boardWidth = boardRect.width - 6; // subtract 3px border on each side
                    const boardHeight = boardRect.height - 6;
                    const squareWidth = boardWidth / 8;
                    const squareHeight = boardHeight / 8;

                    // Calculate center positions using grid coordinates
                    const fromX = (fromCol * squareWidth) + (squareWidth / 2);
                    const fromY = (fromRow * squareHeight) + (squareHeight / 2);
                    const toX = (toCol * squareWidth) + (squareWidth / 2);
                    const toY = (toRow * squareHeight) + (squareHeight / 2);

                    const deltaX = toX - fromX;
                    const deltaY = toY - fromY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;

                    // Line starts from exact center of circle
                    line.style.width = distance + 'px';
                    line.style.left = fromX + 'px';
                    line.style.top = (fromY - 2) + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.transformOrigin = '0 center';

                    chessboard.appendChild(line);
                    gameState.currentAiMoveLine = line;

                    // Create red circle at source position
                    const circle = document.createElement('div');
                    circle.className = 'ai-move-circle';
                    circle.style.left = fromX + 'px';
                    circle.style.top = fromY + 'px';
                    chessboard.appendChild(circle);

                    // Create arrow at destination position
                    const arrow = document.createElement('div');
                    arrow.className = 'ai-move-arrow';
                    arrow.style.left = toX + 'px';
                    arrow.style.top = toY + 'px';
                    // Rotate arrow to point in the direction of movement
                    arrow.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
                    chessboard.appendChild(arrow);

                    // Store references for cleanup
                    gameState.currentAiMoveCircle = circle;
                    gameState.currentAiMoveArrow = arrow;

                    // Step 3: Clean up after red line has been shown
                    setTimeout(() => {
                        // Remove only animated piece, keep line, circle, and arrow visible
                        animatedPiece.remove();
                        // Keep visual indicators visible: line, circle, and arrow remain on screen
                        // Show piece in new position
                        piece.style.opacity = '1';
                        if (callback) callback();
                    }, 1500); // Red line display duration
                }, 1500); // Wait for piece movement to complete
            }, 100); // Initial delay
        }

        function performAiMoveVisualization(fromRow, fromCol, toRow, toCol, callback) {
            gameState.aiMoveInProgress = true;
            gameState.lastAiMove = {fromRow, fromCol, toRow, toCol};

            // Clear previous AI move indicators before showing new ones
            if (gameState.currentAiMoveLine) {
                gameState.currentAiMoveLine.remove();
                gameState.currentAiMoveLine = null;
            }
            if (gameState.currentAiMoveCircle) {
                gameState.currentAiMoveCircle.remove();
                gameState.currentAiMoveCircle = null;
            }
            if (gameState.currentAiMoveArrow) {
                gameState.currentAiMoveArrow.remove();
                gameState.currentAiMoveArrow = null;
            }

            // Step 1: Blink the piece
            blinkAiPiece(fromRow, fromCol, () => {
                // Step 2: Animate the move
                animateAiPieceMove(fromRow, fromCol, toRow, toCol, () => {
                    gameState.aiMoveInProgress = false;
                    // Update status message now that animation is complete
                    updateStatus();
                    if (callback) callback();
                });
            });
        }

        function detectAiMove(oldBoard, newBoard) {
            if (!oldBoard || !newBoard) {
                console.log("detectAiMove: Missing board data");
                return null;
            }

            let changes = [];
            let fromSquare = null;
            let toSquare = null;

            // Find all squares that changed
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const oldPiece = oldBoard[row] ? oldBoard[row][col] || '' : '';
                    const newPiece = newBoard[row] ? newBoard[row][col] || '' : '';

                    if (oldPiece !== newPiece) {
                        changes.push({
                            row: row,
                            col: col,
                            old: oldPiece,
                            new: newPiece
                        });
                    }
                }
            }

            console.log("detectAiMove: Changes detected:", changes);


            // Look for a black piece that moved (disappeared from one square, appeared on another)
            for (let change of changes) {
                if (change.old && change.old.startsWith('b') && !change.new) {
                    fromSquare = {row: change.row, col: change.col, piece: change.old};
                    console.log("detectAiMove: Found FROM square:", fromSquare);
                } else if (change.new && change.new.startsWith('b') && !change.old) {
                    toSquare = {row: change.row, col: change.col, piece: change.new};
                    console.log("detectAiMove: Found TO square:", toSquare);
                }
            }

            if (fromSquare && toSquare && fromSquare.piece === toSquare.piece) {
                const move = {
                    from: {row: fromSquare.row, col: fromSquare.col},
                    to: {row: toSquare.row, col: toSquare.col},
                    piece: fromSquare.piece
                };
                console.log("detectAiMove: Returning move:", move);
                return move;
            }

            console.log("detectAiMove: No valid move found");
            return null;
        }

        // Move handling with AI triggering
        function attemptMove(fromRow, fromCol, toRow, toCol) {
            const moveString = `${fromRow},${fromCol},${toRow},${toCol}`;
            const formData = new FormData();
            formData.append('move', moveString);

            fetch('/api/move', {
                method: 'POST',
                body: formData
            })
            .then(r => r.json())
            .then(result => {
                if (result.status === 'move_accepted') {
                    gameState.showGameReady = false; // Clear Game Ready flag after first move
                    updateBoard(); // Show user move
                    updateStatus(); // Update message to show black thinking

                    // Trigger AI move after a short delay
                    setTimeout(() => {
                        // Capture board state before AI move
                        fetch('/api/board')
                            .then(r => r.json())
                            .then(boardData => {
                                gameState.preAiBoard = boardData.board;

                                // Now request AI move
                                fetch('/api/request-ai-move', {method: 'POST'})
                                    .then(() => {
                                        // Wait for AI to process, then check for move and animate
                                        setTimeout(() => {
                                            fetch('/api/board')
                                                .then(r => r.json())
                                                .then(newBoardData => {
                                                    console.log("=== AI MOVE DETECTION DEBUG ===");
                                                    console.log("Pre-AI board:", gameState.preAiBoard);
                                                    console.log("Post-AI board:", newBoardData.board);

                                                    const aiMove = detectAiMove(gameState.preAiBoard, newBoardData.board);
                                                    console.log("Detected AI move:", aiMove);

                                                    if (aiMove) {
                                                        console.log(`Animating move from (${aiMove.from.row},${aiMove.from.col}) to (${aiMove.to.row},${aiMove.to.col})`);
                                                        // Animate FIRST (while piece is still at source position)
                                                        performAiMoveVisualization(
                                                            aiMove.from.row, aiMove.from.col,
                                                            aiMove.to.row, aiMove.to.col,
                                                            () => {
                                                                // THEN update board to final positions after animation
                                                                updateBoard();
                                                                // Status will be updated by the animation completion callback
                                                            }
                                                        );
                                                    } else {
                                                        console.log("No AI move detected, updating board normally");
                                                        // No animation detected, just update normally
                                                        updateBoard();
                                                        updateStatus();
                                                    }
                                                });
                                        }, 1000);
                                    });
                            });
                    }, 1000);
                } else {
                    alert('Invalid move: ' + (result.message || 'Move not allowed'));
                }
            })
            .catch(e => {
                alert('Error communicating with server');
            });
        }

        // Game initialization is now handled by the loading system
        // Periodic updates that respect drag state
        setInterval(() => {
            if (backgroundUpdatesEnabled) {
                updateBoard();
            }
        }, 5000);

        setInterval(() => {
            if (backgroundUpdatesEnabled) {
                updateStatus();
            }
        }, 3000);
    </script>
</body>
</html>